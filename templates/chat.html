<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SafeChat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/node-forge@1.0.0/dist/forge.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@joeattardi/emoji-button@4.6.4/dist/index.min.js"></script>
    <link rel="stylesheet" href="../static/styles.css">
</head>
<body>
<div id="control-panel">
    Status: <span id="connection-status" class="status-ok">Po≈ÇƒÖczono</span><br>
    <button onclick="manualDisconnect()">Roz≈ÇƒÖcz</button>
    <button onclick="manualReconnect()">Po≈ÇƒÖcz</button>
    <button onclick="quitChat()" style="color: red; font-weight: bold; margin-left: 10px;">Wyjd≈∫</button>
</div>
<script type="text/javascript" charset="utf-8">
    const socket = io();
    let myNick = "";
    let myPrivateKey = null;
    let myPublicKey = null;
    var rsa = forge.pki.rsa;
    let peerPublicKeys = {}
    let roomAESKey = null;

    // Funkcja umo≈ºliwiajƒÖca wys≈Çanie klucza na serwer
    function joinChat() {
        if (!myNick || !myPublicKey) return;
        // Konwersja klucza na tekst (w formacie PEM), inaczej nie mo≈ºna wys≈Çaƒá przez socket
        const publicKeyPEM = forge.pki.publicKeyToPem(myPublicKey);
        socket.emit('join', myNick, publicKeyPEM);
        document.getElementById("greeting").innerText = myNick + " (Ty)";
    }

    // Funkcja odpowiadajƒÖca za opuszczenie czatu. Czy≈õci element z pamiƒôci przeglƒÖdarki oraz wykonuje przekierowanie na stronƒô logowania
    function quitChat() {
        socket.disconnect();

        roomAESKey = null;
        myPrivateKey = null;
        myPublicKey = null;
        peerPublicKeys = {};

        localStorage.removeItem("savedNickname");

        window.location.href = "/";
    }

    // Funkcja odpowiadajƒÖca za wysy≈Çanie zaszyfrowanych wiadomo≈õci
    function sendMessage() {

        //Pobiera wiadomo≈õƒá z pola tekstowego
        const messageInput = document.getElementById("message-input");
        const msg = messageInput.value;

        //Je≈ºeli u≈ºytkownik wpisze komendƒô, to wykonuje inne czynno≈õci
         if(msg.trim() === "/quit"){
            quitChat()
            return;
        }
        else if (msg.trim() === "/list"){
            const item = document.getElementById('users')
            item.style.backgroundColor = "red";
            return
        }
        else if (msg.trim() === "/help"){
            alert("Witaj w bezpiecznym czacie:\n1. Wiadomo≈õƒá nie mo≈ºe byc d≈Çu≈ºsza ni≈º 1024 znaki\n2. Historia czatu zapisuje siƒô do maksymalnie 10 wiadomo≈õci");
            return
        }
        else if (msg.length > 1024){
            alert("Wiadomo≈õƒá nie mo≈ºe byƒá d≈Çu≈ºsza ni≈º 1024 znaki!");
            return;
        }
        if (!roomAESKey || msg.trim()==="") {
            return;
        }

        // Losuje 16-bajtowy wektor inicjujƒÖcy
        var iv = forge.random.getBytesSync(16);

        // Tworzy obiekt szyfrujƒÖcy, u≈ºywajƒÖc wsp√≥lnego klucza AES
        var cipher = forge.cipher.createCipher('AES-CBC', roomAESKey);
        cipher.start({iv: iv});

        // Konwertuje tekst na bajty
        cipher.update(forge.util.createBuffer(msg, 'utf8'));
        cipher.finish();

        // Konwertuje na HEX
        var encryptedHex = cipher.output.toHex();
        var ivHex = forge.util.bytesToHex(iv);
        var payload = ivHex + ';' + encryptedHex;

        // Wysy≈Çka zaszyfrowanej wiadomo≈õci do serwera
        socket.emit('message', payload);
        messageInput.value = "";
}

    // Funkcja wykonujƒÖca zerwanie po≈ÇƒÖczenia (symuluje chwilowy brak po≈ÇƒÖczenia z internetem)
    function manualDisconnect() {
        const statusSpan = document.getElementById("connection-status");
        statusSpan.innerText = "Utracono po≈ÇƒÖczenie";
        socket.disconnect(); // Manualne zerwanie po≈ÇƒÖczenia
    }

    // Funkcja przywracajƒÖca po≈ÇƒÖczenie
    function manualReconnect() {
        const statusSpan = document.getElementById("connection-status");
        statusSpan.innerText = "Po≈ÇƒÖczono";
        socket.connect(); // Manualne wznowienie (wywo≈Ça event 'connect' powy≈ºej)
    }

    // Generuje klucze RSA (publiczny oraz prywatny)
    rsa.generateKeyPair({bits: 2048, workers: 2}, function (err, keypair) {
        if (err) {
                    console.error("B≈ÇƒÖd generowania kluczy:", err);
                    return;
                }

        myPrivateKey = keypair.privateKey;
        myPublicKey = keypair.publicKey;

        myNick = localStorage.getItem("savedNickname");

        if (myNick) {
            joinChat();
        } else {
            window.location.href = "/";
        }
    });

    // Po po≈ÇƒÖczeniu przez u≈ºytkownika wy≈õwietla aktualny status oraz wykonuje funkcje
    socket.on('connect', function() {
        const statusSpan = document.getElementById("connection-status");
        statusSpan.innerText = "Po≈ÇƒÖczono";
        statusSpan.className = "status-ok";

        if (myPublicKey && myNick) {
            joinChat();
        }
    });

    // Odbiera tablicƒô (historiƒô) zaszyfrowanych wiadomo≈õci od serwera, nastƒôpnie ja deszyfruje
    socket.on('update_history', function(messages_history) {

        const listElement = document.getElementById("history");
        listElement.innerHTML = "";

        // Wykonuje deszyfrowanie dla ka≈ºdej wiadomo≈õci w historii
        messages_history.forEach(function(msg_obj) {
            const item = document.createElement("li");

            let displayText = msg_obj.message;

            // Sprawdza czy dane zawierajƒÖ prawid≈Çowe informacje
            if (roomAESKey && msg_obj.message.includes(';')) {
                try {
                    const parts = msg_obj.message.split(';');
                    const iv = forge.util.hexToBytes(parts[0]);
                    const encrypted = forge.util.hexToBytes(parts[1]);

                    // Tworzy obiekt deszyfrujƒÖcy u≈ºywajƒÖc wsp√≥lnego roomAESKey
                    const decipher = forge.cipher.createDecipher('AES-CBC', roomAESKey);
                    decipher.start({iv: iv});
                    decipher.update(forge.util.createBuffer(encrypted));

                    // Deszyfrowanie
                    const result = decipher.finish();

                    if(result) {

                        // Zamiana bajt√≥w na tekst
                        displayText = decipher.output.toString('utf8');
                    }
                } catch (e) { }
            }

            item.innerText = msg_obj.nickname + ": " + displayText;

            // Sprawdza, do kogo nale≈ºy wiadomo≈õƒá i przypisuje odpowiedniƒÖ klasƒô
            if (msg_obj.nickname === myNick) item.className = "my-msg";
            else item.className = "other-msg";

            item.classList.add("last-message");


            listElement.appendChild(item);
        });
    })

    // Odbiera, zapisuje oraz wy≈õwietla listƒô aktualnie po≈ÇƒÖczonych u≈ºytkownik√≥w
    socket.on('current_users', function(all_current_users) {
        const usersContainer = document.getElementById('users');
        usersContainer.innerHTML = '';

        const otherNicks = Object.keys(all_current_users);

        // Tworzy i wyswietla element dla ka≈ºdego po≈ÇƒÖczonego u≈ºytkownika
        otherNicks.forEach(function(nickname) {
            const div = document.createElement('div');
            div.innerText = nickname;
            usersContainer.appendChild(div);

            // Pobiera klucz w formacie tekstowym
            const pem = all_current_users[nickname];

            // Konweruje klucz na obiekt i zapisuje
            peerPublicKeys[nickname] = forge.pki.publicKeyFromPem(pem);
        });

        // Je≈ºeli nie ma innych u≈ºytkownik√≥w i nie mam jeszcze klucza AES pokoju, to generuje nowy
        if (otherNicks.length === 0 && roomAESKey === null) {
            roomAESKey = forge.random.getBytesSync(32);
        }

    });

    // Funkcja przyjmujƒÖca zdarzenie do≈ÇƒÖczenia nowego u≈ºytkownika
    socket.on('user_joined', function(new_user_data) {

            const usersContainer = document.getElementById('users');
            const div = document.createElement('div');
            div.innerText = new_user_data.nickname;
            usersContainer.appendChild(div);

            // Konwersja z napisu w formacie PEM na obiekt
            const newKey = forge.pki.publicKeyFromPem(new_user_data.publicKey);

            // Zapisanie w s≈Çowniku pod nickem u≈ºytkownika
            peerPublicKeys[new_user_data.nickname] = newKey;

            // Je≈õli u≈ºytkownik posiada klucz, to przekazuje go nowemu u≈ºytkownikowi
            if (roomAESKey) {
                try {
                    // Szyfruje wsp√≥lny klucz AES za pomocƒÖ klucza publicznego nowego u≈ºytkownika
                    const encryptedAESKey = newKey.encrypt(roomAESKey);

                    // Wysy≈Ça zaszyfrowany klucz do u≈ºytkownika
                    socket.emit('send_key_to_user', {
                        encrypted_key: encryptedAESKey,
                        target_sid: new_user_data.sid
                    });
                } catch(e) {}
            }
        });

    // Odpowiada za przyjƒôcie klucza oraz deszyfrowanie klucza za pomocƒÖ klucza prywatnego
    socket.on('receive_key', function(data) {
        try {
            const decryptedKey = myPrivateKey.decrypt(data.key);
            roomAESKey = decryptedKey;
        } catch(e) {
        }
    });

    // Obs≈Çuguje zdarzenie opuszczenia czatu przez u≈ºytkownika
    socket.on('user_left', function(nickname) {

        // Usuwa klucz u≈ºytkownika, kt√≥ry opu≈õci≈Ç czat
        delete peerPublicKeys[nickname];

        const usersContainer = document.getElementById('users');
        const divs = usersContainer.getElementsByTagName('div');

        // Usuwa u≈ºytkownika z listy
        for (let i = 0; i < divs.length; i++) {
            if (divs[i].innerText === nickname) {
                usersContainer.removeChild(divs[i]);
                break;
            }
        }
    });

</script>

<!-- Inicjalizacja biblioteki emoji-picker i obs≈Çuga wstawiania emotikon do pola tekstowego -->
<script type="module">
    import { createPopup } from 'https://unpkg.com/@picmo/popup-picker@latest/dist/index.js?module';

    window.addEventListener('DOMContentLoaded', () => {
        const trigger = document.querySelector('#emoji-trigger');
        const input = document.querySelector('#message-input');

        const picker = createPopup({}, {
            referenceElement: trigger,
            triggerElement: trigger,
            position: 'top-start'
        });

        trigger.addEventListener('click', () => {
            picker.toggle();
        });

        picker.addEventListener('emoji:select', (selection) => {
            input.value += selection.emoji;
            input.focus();
        });
    });
</script>


<div id="input-area">
    <input type="text" id="message-input" placeholder="Wpisz wiadomo≈õƒá..." autocomplete="off">
    <button onclick="sendMessage()">Wy≈õlij</button>
    <button id="emoji-trigger" style="font-size: 1.2rem; cursor: pointer; margin-right: 5px;">üòÄ</button>
</div>
<center><h1>Czat</h1></center>
<center><p>U≈ºytkownicy online:</p> </center>
<center><strong><div id="greeting"></div></strong></center>
<center><div id="users"></div></center>
<div id="history">


</div>
</body>
</html>